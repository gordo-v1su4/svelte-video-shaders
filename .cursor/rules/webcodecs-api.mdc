# WebCodecs API Best Practices

This document outlines the core principles and patterns to follow when using the WebCodecs API to ensure performance, stability, and maintainability.

## 1. The Golden Rule: Close Your Frames

The most critical rule when working with WebCodecs is to **explicitly release resources** as soon as they are no longer needed.

- **Always call `frame.close()`:** After a `VideoFrame` or `AudioData` object has been used (e.g., rendered to a canvas, processed), you **must** call its `close()` method.
- **Why:** These objects hold references to large, limited system resources (like hardware decoder memory). Waiting for the garbage collector is not sufficient and will lead to performance degradation, stuttering, and eventual crashes as the system runs out of memory.

```javascript
// ✅ Correct: Close the frame after use.
const videoDecoder = new VideoDecoder({
  output: (frame) => {
    // Do something with the frame, e.g., draw it to a canvas.
    ctx.drawImage(frame, 0, 0);
    // Immediately close the frame to release its memory.
    frame.close();
  },
  error: (e) => console.error(e),
});

// ❌ Incorrect: Forgetting to close the frame will cause memory leaks.
const videoDecoder = new VideoDecoder({
  output: (frame) => {
    ctx.drawImage(frame, 0, 0);
    // Forgetting frame.close() here is a critical bug.
  },
  // ...
});
```

## 2. State Management and Lifecycle

Every codec instance (`VideoDecoder`, `VideoEncoder`, etc.) follows a strict lifecycle. Respecting this state model is essential for preventing errors.

- **States:** `unconfigured`, `configured`, `closed`.
- **Lifecycle:**
    1.  **Construct:** Create the codec with `output` and `error` callbacks.
    2.  **Configure:** Call `codec.configure({...})` with the specific codec parameters. Always check for support first with `VideoDecoder.isConfigSupported({...})`.
    3.  **Process:** Call `codec.decode()` or `codec.encode()` only when the state is `configured`.
    4.  **Close:** When the component is destroyed or the codec is no longer needed, call `codec.close()` to release all underlying system resources.

```javascript
// ✅ Correct: Full lifecycle management.
let decoder;

// In component initialization:
async function setup() {
  const config = { codec: 'vp09.00.10.08', /* ... */ };
  if (!(await VideoDecoder.isConfigSupported(config))) {
    console.error('Configuration not supported.');
    return;
  }
  decoder = new VideoDecoder({ output: handleFrame, error: handleError });
  decoder.configure(config);
}

// In component destruction:
function cleanup() {
  if (decoder && decoder.state !== 'closed') {
    decoder.close();
  }
}
```

## 3. Asynchronous Operations and Error Handling

WebCodecs is highly asynchronous. Handle errors using both promise rejections and the required `error` callback.

- **Promise Rejections:** `configure()` and `flush()` return Promises. Always use `.catch()` to handle configuration or flushing errors.
- **Error Callback:** The `error` callback passed during construction is for *unrecoverable* errors. When this is called, the codec is automatically moved to the `closed` state. Your application should handle this gracefully.

```javascript
// ✅ Correct: Handle both promise rejections and the error callback.
try {
  await decoder.configure(config);
} catch (e) {
  console.error('Failed to configure decoder:', e);
  return;
}

const decoder = new VideoDecoder({
  // ...
  error: (e) => {
    // This is a fatal error. The decoder is now closed.
    // Update UI or application state accordingly.
    console.error('Unrecoverable decoder error:', e);
  },
});
```

## 4. Data Flow with `mp4box.js`

When demuxing with a library like `mp4box.js`, ensure the data flows correctly into the decoder.

- **`onReady`:** Use the `onReady` callback from `mp4box.js` to get the codec configuration info and configure the `VideoDecoder`.
- **`onSamples`:** Use the `onSamples` callback to receive the encoded chunks. Create a new `EncodedVideoChunk` for each sample and pass it to `decoder.decode()`.

```javascript
// In mp4boxfile.onReady:
const track = info.tracks.find(t => t.type === 'video');
decoder.configure({ codec: track.codec, ... });
mp4boxfile.setExtractionOptions(track.id);
mp4boxfile.start();

// In mp4boxfile.onSamples:
for (const sample of samples) {
  const chunk = new EncodedVideoChunk({
    type: sample.is_sync ? 'key' : 'delta',
    timestamp: sample.cts,
    duration: sample.duration,
    data: sample.data,
  });
  if (decoder.state === 'configured') {
    decoder.decode(chunk);
  }
}
```

## 5. H.264 (AVC) Specific Requirements

According to the [W3C WebCodecs AVC registration specification](https://www.w3.org/TR/webcodecs-avc-codec-registration/), H.264 videos have specific requirements that differ from other codecs.

### AVC Format vs Annex B Format

H.264 videos can be in two formats:

- **`avc` format** (MP4 containers): Parameter sets (SPS/PPS) stored separately in container metadata
- **`annexb` format** (streaming): Parameter sets included periodically in the bitstream

### Critical Rule: Description Field for AVC Format

**For H.264 videos in `avc` format (standard MP4 files), the `description` field is REQUIRED in `VideoDecoderConfig`:**

```javascript
// ✅ Correct: H.264 AVC format with description field
const config = {
  codec: 'avc1.64001f',
  codedWidth: 1280,
  codedHeight: 720,
  description: avccDescriptionBuffer // ✅ REQUIRED for avc format
};

// ❌ Incorrect: Missing description field will cause DataError
const config = {
  codec: 'avc1.64001f',
  codedWidth: 1280,
  codedHeight: 720
  // Missing description field - decoder will fail
};
```

### Extracting H.264 Description from MP4

The `description` field must contain an `AVCDecoderConfigurationRecord`. Extract it from MP4 metadata:

```javascript
// ✅ Good: Extract H.264 description from track metadata
function getAvccDescription(track) {
  // Path 1: Check for pre-packaged avcC box
  if (track.description?.entries) {
    for (const entry of track.description.entries) {
      const avccBox = entry.boxes?.find(b => b.type === 'avcC');
      if (avccBox?.data) {
        return avccBox.data; // AVCDecoderConfigurationRecord
      }
    }
  }
  
  // Path 2: Manually construct from SPS/PPS
  if (track.avcC?.SPS && track.avcC?.PPS) {
    return constructAvccDescription(track.avcC);
  }
  
  return null;
}

// Configure decoder with description
const track = info.videoTracks[0];
const config = {
  codec: track.codec,
  codedWidth: track.track_width,
  codedHeight: track.track_height
};

if (track.codec.startsWith('avc1')) {
  const description = getAvccDescription(track);
  if (description) {
    config.description = description;
  } else {
    console.error('H.264 avc format requires description field');
  }
}
```

### Common H.264 Errors and Solutions

**Error: "A key frame is required after configure() or flush(). If you're using AVC formatted H.264 you must fill out the description field"**

- **Cause**: Missing `description` field in `VideoDecoderConfig` for `avc` format H.264
- **Solution**: Extract `AVCDecoderConfigurationRecord` from MP4 metadata and add to config

**Error: "Failed to execute 'isConfigSupported' on 'VideoDecoder': The provided value is not of type 'VideoDecoderConfig'"**

- **Cause**: Invalid or incomplete configuration object
- **Solution**: Ensure all required fields (`codec`, `codedWidth`, `codedHeight`) are present and valid

### H.264 Format Detection

```javascript
// ✅ Good: Detect H.264 format and handle accordingly
if (track.codec.startsWith('avc1')) {
  // This is H.264 in avc format (MP4) - description required
  const description = getAvccDescription(track);
  if (description) {
    config.description = description;
  }
} else if (track.codec.startsWith('avc3')) {
  // This is H.264 in annexb format - no description needed
  console.log('H.264 annexb format detected');
}
```

## 6. SvelteKit Integration Patterns

When using WebCodecs in SvelteKit, you must handle Server-Side Rendering (SSR) correctly.

### SSR Gating with onMount

**All WebCodecs code must be gated behind `onMount` or browser checks:**

```javascript
// ✅ Correct: WebCodecs code in onMount (browser-only)
import { onMount } from 'svelte';

onMount(() => {
  // Safe to use WebCodecs here - only runs in browser
  const decoder = new VideoDecoder({
    output: (frame) => {
      // Handle frame
      frame.close();
    },
    error: (e) => console.error(e)
  });
  
  return () => {
    // Cleanup on component destroy
    if (decoder && decoder.state !== 'closed') {
      decoder.close();
    }
  };
});

// ❌ Incorrect: WebCodecs at top level will break SSR
const decoder = new VideoDecoder({ ... }); // Error: window is not defined
```

### Browser Environment Check

```javascript
// ✅ Alternative: Browser check before using WebCodecs
if (typeof window !== 'undefined' && window.VideoDecoder) {
  const decoder = new VideoDecoder({ ... });
}
```

## 7. ImageBitmap Conversion Pattern

For persistent frame storage and WebGL integration, convert VideoFrames to ImageBitmaps:

```javascript
// ✅ Correct: Convert VideoFrame to ImageBitmap, then close immediately
const videoDecoder = new VideoDecoder({
  output: (frame) => {
    // Create ImageBitmap copy (GPU-resident for WebGL)
    createImageBitmap(frame).then(bitmap => {
      // Store bitmap for later use
      frames.push(bitmap);
      // Update progress, etc.
    }).catch(e => {
      console.error('Failed to create ImageBitmap:', e);
    }).finally(() => {
      // CRITICAL: Always close VideoFrame immediately to free decoder buffers
      frame.close();
    });
  },
  error: (e) => console.error(e)
});
```

**Why ImageBitmap?**
- GPU-resident (stays on GPU for WebGL textures)
- Persistent (can be stored in arrays for random access)
- Safe (VideoFrame must be closed immediately, ImageBitmap can live longer)

**Trade-off:** Slight overhead from conversion, but enables pre-decoded frame buffers for instant seeking.

## 8. Queue Management for Rapid Seeks

During rapid clip swapping or seeking, implement queue management to prevent jitter:

```javascript
// ✅ Correct: Queue management for rapid seeks
let seekQueue = [];
let isProcessingSeek = false;

function seekToFrame(targetFrame) {
  seekQueue.push(targetFrame);
  
  // If queue is too long, skip to latest
  if (seekQueue.length > 3) {
    seekQueue = [targetFrame]; // Keep only the latest
  }
  
  processSeekQueue();
}

async function processSeekQueue() {
  if (isProcessingSeek || seekQueue.length === 0) return;
  
  isProcessingSeek = true;
  const targetFrame = seekQueue.pop();
  seekQueue = []; // Clear queue, we're processing the latest
  
  // Perform seek operation
  await performSeek(targetFrame);
  
  isProcessingSeek = false;
  
  // Process any new seeks that arrived during processing
  if (seekQueue.length > 0) {
    processSeekQueue();
  }
}
```

**Benefits:**
- Prevents decoder from being overwhelmed
- Ensures UI stays responsive
- Skips intermediate seeks to maintain "tactile" feel

## 9. CSS-First Rendering for Performance

For UI elements that update frequently (progress bars, opacity), use CSS Custom Properties instead of Svelte reactive state:

```javascript
// ✅ Correct: CSS Custom Properties for 60fps updates
function updateProgress(percent) {
  const progressBar = document.querySelector('.progress-bar');
  if (progressBar) {
    progressBar.style.setProperty('--progress', `${percent}%`);
  }
}

// In CSS:
.progress-bar::before {
  width: var(--progress);
  transition: width 0.1s;
}

// ❌ Incorrect: Reactive state causes re-renders at 60fps
let progress = $state(0); // Triggers Svelte reactivity every frame
```

**Why?** Keeps Svelte out of the 60fps render loop, allowing browser's native CSS engine to handle visual updates efficiently.

## 10. Web Workers Consideration

For heavy decoding operations, consider moving to Web Workers:

```javascript
// ✅ Good: Pre-decode-all during load (acceptable on main thread)
// All frames decoded upfront, then accessed instantly
await frameBuffer.preloadClips(videoFiles);

// ⚠️ Consider: Real-time decoding during playback
// If decoding happens during playback, move to Web Worker:
const worker = new Worker('/video-decoder-worker.js');
worker.postMessage({ action: 'decode', chunk: encodedChunk });
worker.onmessage = (e) => {
  const frame = e.data.frame;
  // Use frame, then close
  frame.close();
};
```

**Current Approach:** Pre-decode-all during load is acceptable on main thread since it's a one-time operation. Real-time decoding during playback could benefit from Web Workers to prevent UI freezes.

## References

- [W3C WebCodecs AVC Registration](https://www.w3.org/TR/webcodecs-avc-codec-registration/)
- [WebCodecs API Specification](https://www.w3.org/TR/webcodecs/)
- [MP4Box.js Documentation](https://github.com/gpac/mp4box.js)
- [webcodecs-frame-buffer.js](mdc:src/lib/webcodecs-frame-buffer.js) - Pre-decoded frame buffer implementation
- [ShaderPlayer.svelte](mdc:src/lib/ShaderPlayer.svelte) - WebCodecs + Three.js integration
